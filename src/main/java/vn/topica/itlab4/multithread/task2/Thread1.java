package vn.topica.itlab4.multithread.task2;

import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 
 * @author AnhLT14
 */
public class Thread1 extends Thread {
	Store store;// initiate a Store

	/**
	 * constructor with parameter store 
	 * to get the store whenever create Thread1 
	 * to manipulate store's information
	 */
	public Thread1(Store store) {
		this.store = store;
	}

	@Override
	public void run() {
		/**
		 *  initiate an AtomicInteger index 
		 *  to automatically increase the field index of object Lamp 
		 *  whenever a new one created
		 */
		AtomicInteger index = new AtomicInteger();

		System.out.println("Thread 1 is running");//show that thread 1 is running
		while (true) {//internal loop
			Random ran = new Random();// initiate a Random ran to randomly generate a number
			int randomNumber = ran.nextInt(20) + 1;// assign variable randomNumber to the random value generated by
													// ran.nextInt()
			System.out.println("Random number of lamps to generate: " + randomNumber);// print out the random number generated
			
			/**
			 * use for loop to create "randomNumber" objects Lamp add them to lampStore
			 * whenever a lamp is created, get the Thread1 sleep 100ms
			 */
			for (int i = 0; i < randomNumber; i++) {
				Lamp lamp = new Lamp(index.getAndIncrement());// create new object Lamp

				store.saveToStore(lamp);// save new object lamp created to Store

				// print out the lamps added to store
				System.out.println("Thread 1 add new lamp to store: " + lamp.toString());

				try {
					Thread.sleep(100);// get Thread1 sleep 100ms
				} catch (InterruptedException ex) {// catch the exception
					Logger.getLogger(Thread1.class.getName()).log(Level.SEVERE, null, ex);// log out the exception
				}
			}
		}
	}
}
